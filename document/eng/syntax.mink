// SPDX-FileCopyrightText: 2025 Oscar Bender-Stone <oscar-bender-stone@protonmail.com>
// SPDX-License-Identifier: CC-BY-SA-4.0
// vim: set filetype=asciidoc:

= Syntax =

// TODO: introduce string substitution.
// This will make contatenation easier.

== Strings ==

We introduce five symbols:

* `0`, denoting the zero bit.

* `1`, denoting one bit.

* `B`, denoting a bit.

* `E`, denoting the empty web.

* ``, denotating contatenation.

A `bit` `B` is either `0` or `1`.
As notation, a sequence of bits starts with `0b`. Bits are read from left to right.

A *binary string* is defined recursively:

* Base case: `0` and `1` are binary strings.

* Recursive case: if `s` is a binary string,
then `s0` is a binary string and `s1` is a binary string.

A *byte* is a sequence of eight bits: `0bBBBBBBBB`.

An  *ASCII character* is a byte `0b0BBBBBBB`. A *printable character* is either `0b00BBBBBB` or `0b1111110`.

Each printable character
is displayed in Tables 1-5,
along with a symbol called
a *grapheme*. Each table is denoted with a unique string called a *character class*.

*Table 1.* Punctuation. Character Class: `\\p{Punct}`.

[cols=2]
|===
   *Byte*    | *Grapheme*
`0b00100001` | `!`
`0b00100010` | `"`
`0b00100011` | `#`
`0b00100100` | `$`
`0b00100101` | `%`
`0b00100110` | `&`
`0b00100111` | `'`
`0b00101000` | `(`
`0b00101001` | `)`
`0b00101010` | `*`
`0b00101011` | `+`
`0b00101100` | `,`
`0b00101101` | `-`
`0b00101110` | `.`
`0b00101111` | `/`
`0b01111010` | `:`
`0b01111011` | `;`
`0b01111100` | `<`
`0b01111101` | `=`
`0b01111110` | `>`
`0b01001111` | `?`
`0b01000000` | `@`
`0b01010011` | `[`
`0b01011100` | `\`
`0b01001101` | `]`
`0b01001110` | `^`
`0b01001111` | `_`
`0b01110000` | `+ ` +`
`0b01110000` | `{`
`0b01111101` | `|`
`0b01111110` | `}`
`0b01111111` | `~`
|===

*Table 2.* Upper-case letters. Character Class: `[A-Z]`.
|===
`0b01000001` | `A`
`0b01000010` | `B`
`0b01000011` | `C`
`0b01000100` | `D`
`0b01000101` | `E`
`0b01000110` | `F`
`0b01000111` | `G`
`0b01001000` | `H`
`0b01001001` | `I`
`0b01001010` | `J`
`0b01001011` | `K`
`0b01001100` | `L`
`0b01001101` | `M`
`0b01001110` | `N`
`0b01001111` | `O`
`0b01010000` | `P`
`0b01010001` | `Q`
`0b01010010` | `R`
`0b01010011` | `S`
`0b01010100` | `T`
`0b01010101` | `U`
`0b01010110` | `V`
`0b01010111` | `W`
`0b01011000` | `X`
`0b01011001` | `Y`
`0b01011010` | `Z`
|===

*Table 3.* Lower-case letters. Character Class: `[a-z]`.
|===
`0b01100001` | `a`
`0b01100010` | `b`
`0b01100011` | `c`
`0b01100100` | `d`
`0b01100101` | `e`
`0b01100110` | `f`
`0b01100111` | `g`
`0b01101000` | `h`
`0b01101001` | `i`
`0b01101010` | `j`
`0b01101011` | `k`
`0b01101100` | `l`
`0b01101101` | `m`
`0b01101110` | `n`
`0b01101111` | `o`
`0b01110000` | `p`
`0b01110001` | `q`
`0b01110010` | `r`
`0b01110011` | `s`
`0b01110100` | `t`
`0b01110101` | `u`
`0b01110110` | `v`
`0b01110111` | `w`
`0b01111000` | `x`
`0b01111001` | `y`
`0b01011010` | `z`
|===

*Table 4.* Digits. Character Class: `[0-9]`.
|===
`0b01100000` | `0`
`0b01100001` | `1`
`0b01100010` | `2`
`0b01100011` | `3`
`0b01100100` | `4`
`0b01100101` | `5`
`0b01100110` | `6`
`0b01100111` | `7`
`0b01101000` | `8`
`0b01101001` | `9`
|===

Additionally, there are composite character classes:

*`\w`: either `[a-z]`, `[A-z]`, or `[0-9]`.

An *ASCII string* is defined recursively:

* Base case: each ASCII character (`0b0BBBBBBB`) is an ASCII string.

* Recursive case: if `s` is an ASCII string, and `c` is an ASCII character, then `sc` is an ASCII string.

It can be readily verified that each ASCII string is a binary string. See Bootstrap for a complete proof.

== Tokens ==

The key building blocks of the syntax include reserved symbols. In order to encode these symbols for users, we introduce special syntax involving quotes
and prefixes.

=== Literals ===

A *single quoted literal string* is defined recursively.

* Base case: the following are single quoted literal strings:
** (in other words, all characters *except* `'`).
** (`\w`).
** `\'`

* Recursive step: if `l` is a single quoted string
and `c` is a binary string satisfying the base case,
then `l.c` is a single quoted string.

A *double quoted literal string* is defined recursively.

* Base case: the following are single quoted literal strings:
** (In other words, all characters *except* `"`).
** (`\w`).
** `\"`

* Recursive step: if `l` is a double quoted string
and `c` is a binary string satisfying the base case,
then `l.c` is a double quoted string.

A *literal string* is a literal single quoted string
or a literal double quoted string.

=== Number Systems ===

As with above, binary strings start with `"0b"`.
Additionally, we support two other systems:

* Decimal: denoted with digits `[0-9]`.
Each digit translates to binary as follows:

Table 5. Decimal to Binary.

[cols=2]
|===
`0` | `0b0000`
`1` | `0b0001`
`2` | `0b0010`
`3` | `0b0011`
`4` | `0b0100`
`5` | `0b0101`
`6` | `0b0110`
`7` | `0b0111`
`8` | `0b1000`
`9` | `0b1001`
|===

* Hexadecimal: a *hexadecimal* digit is denoted by:
either `[0-9]`,
lower-case letters `a`, `b`, `c`, `d`, `e`, or `f`,
or upper-case letters `A`, `B`, `C`, `D`, `E`, and `F`.
Each digit translates to binary as follows:

Table 6. Hexadecimal to Binary.

[cols=2]
|===
`0` | `0b0000`
`1` | `0b0001`
`2` | `0b0010`
`3` | `0b0011`
`4` | `0b0100`
`5` | `0b0101`
`6` | `0b0110`
`7` | `0b0111`
`8` | `0b1000`
`9` | `0b1001`
`a` | `0b1010`
`A` | `0b1010`
`b` | `0b1011`
`B` | `0b1011`
`c` | `0b1100`
`C` | `0b1100`
`d` | `0b1101`
`D` | `0b1101`
`e` | `0b1110`
`E` | `0b1110`
`f` | `0b1111`
`F` | `0b1111`
|===


A hexadecimal number may be written
with all lower-case letters, or all upper-case
letters. More precisely:

* A *lower-case* hexadecimal number is defined recursively:

** Base case: `h` is either `[0-9]` or `[a-z]`.

** Recursive case: if `h` is a lower-case hexadecimal number
and `d` is a digit satisfying the above base case,
then `hd` is a lower-case hexadecimal number.

* An *upper-case* hexadecimal number is defined recursively:

** Base case: `h` is either `[0-9]` or `[A-Z]`.

** Recursive case: if `h` is a upper-case hexadecimal number
and `d` is a digit satisfying the above base case,
then `hd` is a upper-case hexadecimal number.

A *hexadecimal number* is either a lower-cased hexadecimal number
of an upper-case hexadecimal number.

Hexadecimal numbers are denoted with the prefix `0x`.

== Grammar ==

Instead of EBNF,
the grammar is bootstrapped
in a limited subset of Welkin.
This subset can be *completely*
described by a regular expression,
or in a simple recursive statement.
This is called the Minimal Grammar.

// TODO: make sure to clarify this statement.
// A Turing machine *is* required
// for the underlying semantics,
// particularly for merging
// duplicate terms
// or executing any grammars.
// Substitution is implicit,
// requiring this Standard to define.

In fact, the *entire* semantics
can be expressed with the Minimal Grammar;
this is done in the Boostrap.
However, for expressivity,
we include the Full Grammar,
allowing for arbitrary nesting
of terms.

=== Minimal Grammar ===

// TODO: clean this up.
// Make sure it is readable!

For simplicity, we exclude
most of the concepts defined in Tokens.

The *Minimal Welkin* language is defined
as follows:

* A part is either `[a-z]` or `[A-Z]`.

* An arrow is a sequence `(p1 "--" p2? "-->" p3)`,
where `p1`, `p2`, and `p3` are parts.

* A web is a sequence of either parts or arrows,
enclosed by brackets (`"{"` and `"}"`).
This sequence may be empty. In this case,
the web is denoted by `{}`.

* A term is either a part, a web,
or an arc.

* A "Minimal Welkin" string is
defined recursively:

** Base case: any term.

** Recursive case: if `s`
is an accepted string
and `t` is a term,
then `s,t` is accepted
by the grammar.

=== Full Grammar ===

Refer to Tokens for more details
on literals and number systems.

// TODO: finish!

`
start --> terms
`

It can be readily shown that the full grammar
is compatible with the Minimal Grammar.
Additionally, this grammar is *LL(0)*,
ensuring it is unambiguous.
Refer to the Bootstrap for complete proofs.
