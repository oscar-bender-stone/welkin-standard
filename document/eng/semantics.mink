// SPDX-FileCopyrightText: 2025 Oscar Bender-Stone <oscar-bender-stone@protonmail.com>
// SPDX-License-Identifier: CC-BY-SA-4.0
// vim: set filetype=asciidoc:

= Semantics =
// TODO: finalize these!
// This ties back the
// whole purpose of Welkin!

A *web* is defined recursively:

* Base case:

** `{}` is a web.

** Any number is a web.

** Any string literal is a web.

// TODO: flesh this out.
* Recursive case: every sequence
of arcs is a web.

== Key Rules == 

// TODO: determine where to put this
* `a - {} -> b` is equivalent to `a --> b`.


// TODO: finish normal forms?
// When do we know this is a complete list?
// TODO: maybe explain semantic significance?
// a --> b --> a means "a focuses to b, and b focuses to a",
// so that a focuses to itself. But "focus" means "produce"/part-of,
// so we learn nothing! Hence, it just looks like `{}`.
Every Welkin web can be reduced to a normal form, which is a fixed point (and no longer be reduced).
This is weaker than equality and need not preserve labels.

The normal forms are determined by the following rules:

* `{}` is a normal form:

** `a --> a` reduces to `{}`

** `a --> b --> a` reduces to `{}`.

// TODO: is there anything more simpler
// than a regular expression?
// Should a single edge be included?
* `a - 0 -> a` is a normal form:

** `a --> b` reduces to `a - 0 -> a`.

** `a <- 0 -> a` reduces to `a - 0 -> a`.
More generally, any cycle *with all unlabeled arcs* reduces to `{}`.

* `a - d -> c` and `b --> d` implies `a' - b -> c'`.
In particular, `a --> c` implies `a - b -> c` for *any* term b.
The converse need not hold: `a - 0 -> a` is reduced,
but `a --> a` is `{}`.
** This principle ensures that the *least*
such part, modulo the web, is written.

Note that, when combined with the normal form rules,
it is possible for a series of *all* labeled
arcs to produce `{}`. For example:

`a - {c --> d --> c} --> a`.

